import DifficultyChip from '../../components/DifficultyChip'

# [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) <DifficultyChip difficulty="easy" />

## Problem

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

Example 1:

```text
Input: nums = [1,2,3,1]
Output: true
```

Example 2:

```text
Input: nums = [1,2,3,4]
Output: false
```

Example 3:

```text
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
```

## Solution

### Approach 1: Using an Object

To solve this problem, you can use an object to keep track of the count of each element in the array. Then, you can iterate through the object and return true if any element has a count greater than 1.

Here is some sample code that demonstrates this approach:

```javascript
function containsDuplicate(nums) {
  // Create an object to store the count of each element
  const counts = {};

  // Count the number of occurrences of each element in the array
  for (const num of nums) {
    if (counts[num]) {
      counts[num]++;
    } else {
      counts[num] = 1;
    }
  }

  // Iterate through the counts and return true if any element has a count greater than 1
  for (const count of Object.values(counts)) {
    if (count > 1) {
      return true;
    }
  }

  // If we get here, then no element had a count greater than 1
  return false;
}
```

This code has a time complexity of O(n), where n is the length of the array, and a space complexity of O(n), since the object can have at most n elements.

There are couple options to optimize from the code above

### Approach 2: Using a Set

Instead of using an object to store the counts, you can use a Set to store the elements that have already been seen. This will reduce the space complexity to O(m), where m is the number of duplicates in the array, since the Set will only store unique elements. Here is how you could modify the code to use a Set:

```javascript
function containsDuplicate(nums) {
  // Create a Set to store the elements that have already been seen
  const seen = new Set();

  // Iterate through the array and return true if any element has already been seen
  for (const num of nums) {
    if (seen.has(num)) {
      return true;
    } else {
      seen.add(num);
    }
  }

  // If we get here, then no element was seen more than once
  return false;
}
```

### Approach 3: One-Liner

If you are using a version of JavaScript that supports the `Set.prototype.add` method, you can use the following one-liner to solve the problem:

```javascript
function containsDuplicate(nums) {
  return new Set(nums).size !== nums.length;
}
```

This code creates a Set from the array, and then compares the size of the Set to the length of the array. If the size is different, then there must be duplicates in the array. This solution has a time complexity of O(n) and a space complexity of O(m).

## Complexity Analysis

### Time Complexity

The first approach has a time complexity of O(n) because it iterates through the input array once to count the number of occurrences of each element, and then iterates through the counts object once to check if any element has a count greater than 1.

The second approach also has a time complexity of O(n) because it iterates through the input array once to check if any element has already been seen.

The third approach has a time complexity of O(n), because the Set constructor has a time complexity of O(n) when it is given an iterable (such as an array) as an argument. The size property of a Set object has a time complexity of O(1), so the comparison between the size of the Set and the length of the array is a constant-time operation.

Overall, all three approaches have a time complexity of O(n).

### Space Complexity

The space complexity of all three approaches is also O(n), because they all use a data structure (either an object or a Set) to store the elements of the input array, and the size of this data structure will grow as the size of the input array grows.
