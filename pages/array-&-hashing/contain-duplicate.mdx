---
title: Contains Duplicate
description: Given an integer array, return true if any value appears at least twice in the array, and return false if every element is distinct. Three approaches to solve the problem are discussed, with time and space complexity analysis.
keywords: array, duplicate values, time complexity, space complexity, object, set, one-liner
---

import DifficultyChip from '../../components/DifficultyChip'

# [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) <DifficultyChip difficulty="easy" />

<div className="iframe-container">
  <iframe className="responsive-iframe" src="https://www.youtube.com/embed/3OamzN90kPg"
          title="YouTube video player" frameBorder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen></iframe>
</div>

## Problem

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

Example 1:

```text
Input: nums = [1,2,3,1]
Output: true
```

Example 2:

```text
Input: nums = [1,2,3,4]
Output: false
```

Example 3:

```text
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
```

## Solution

### Approach 1: Using Object

To solve this problem, you can use an object to keep track of the count of each element in the array. Then, you can iterate through the object and return true if any element has a count greater than 1.

Here is some sample code that demonstrates this approach:

```javascript
function containsDuplicate(nums) {
  // Create an object to store the count of each element
  const counts = {};

  // Count the number of occurrences of each element in the array
  for (const num of nums) {
    if (counts[num]) {
      counts[num]++;
    } else {
      counts[num] = 1;
    }
  }

  // Iterate through the counts and return true if any element has a count greater than 1
  for (const count of Object.values(counts)) {
    if (count > 1) {
      return true;
    }
  }

  // If we get here, then no element had a count greater than 1
  return false;
}
```

This code has a time complexity of O(n), where n is the length of the array, and a space complexity of O(n), since the object can have at most n elements.

There are couple options to optimize from the code above

#### Complexity Analysis

The time complexity of O(n) because it iterates through the input array once to count the number of occurrences of each element, and then iterates through the counts object once to check if any element has a count greater than 1.

The space complexity of O(n) because the counts object can have at most n elements.

### Approach 2: Using Set

Instead of using an object to store the counts, you can use a Set to store the elements that have already been seen. This will reduce the space complexity to O(m), where m is the number of duplicates in the array, since the Set will only store unique elements. Here is how you could modify the code to use a Set:

```javascript
function containsDuplicate(nums) {
  // Create a Set to store the elements that have already been seen
  const seen = new Set();

  // Iterate through the array and return true if any element has already been seen
  for (const num of nums) {
    if (seen.has(num)) {
      return true;
    } else {
      seen.add(num);
    }
  }

  // If we get here, then no element was seen more than once
  return false;
}
```

#### Complexity Analysis

The time complexity of O(n) because it iterates through the input array once to check if any element has already been seen, and then iterates through the seen Set once to add each element to the Set.

The space complexity of O(m) because the seen Set can have at most m elements.

### Approach 3: One-Liner

If you are using a version of JavaScript that supports the `Set.prototype.add` method, you can use the following one-liner to solve the problem:

```javascript
function containsDuplicate(nums) {
  return new Set(nums).size !== nums.length;
}
```

This code creates a Set from the array, and then compares the size of the Set to the length of the array. If the size is different, then there must be duplicates in the array. This solution has a time complexity of O(n) and a space complexity of O(m).

#### Complexity Analysis

The time complexity of O(n), because the Set constructor has a time complexity of O(n) when it is given an iterable (such as an array) as an argument. The size property of a Set object has a time complexity of O(1), so the comparison between the size of the Set and the length of the array is a constant-time operation.

The space complexity of O(m), because the Set constructor has a space complexity of O(m) when it is given an iterable (such as an array) as an argument.
