---
title: Valid Anagram
description: Given two strings s and t, return true if t is an anagram of s, and false otherwise. Two approaches to solve the problem are discussed, with time and space complexity analysis.
keywords: anagram, strings, characters, s, t
---

import DifficultyChip from '../../components/DifficultyChip';

# [Valid Anagram](https:leetcode.com/problems/valid-anagram) <DifficultyChip difficulty="easy" />

<div className="iframe-container">
  <iframe className="responsive-iframe" src="https://www.youtube.com/embed/9UtInBqnCgA"
          title="YouTube video player" frameBorder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen></iframe>
</div>

## Problem

Given two strings s and t , return true if t is an anagram of s, and false otherwise.

Example 1:

```text
Input: s = "anagram", t = "nagaram"
Output: true
```

Example 2:

```text
Input: s = "rat", t = "car"
Output: false
```

## Solution

### Approach 1: Using a Map and Sorting strings

To solve this problem, we can create a hash map where the keys are the sorted versions of each string in the input array, and the values are arrays containing the anagrams. Then, we can iterate through the input array and add each string to the appropriate value array in the hash map. Finally, we can return the values of the hash map as the solution.

Here is an example of how this can be implemented in JavaScript:

```javascript
function groupAnagrams(strs) {
  // Create an empty hash map
  const map = new Map();

  // Iterate through the input array
  for (const str of strs) {
    // Sort the string
    const sortedStr = str.split('').sort().join('');

    // If the sorted string is not a key in the map, add it and set the value to an array containing the original string
    if (!map.has(sortedStr)) {
      map.set(sortedStr, [str]);
    } else {
      // If the sorted string is already a key in the map, add the original string to the array of values
      map.get(sortedStr).push(str);
    }
  }

  // Return the values of the map as the solution
  return [...map.values()];
}
```

#### Complexity Analysis

This function should have a time complexity of O(n * m * log(m)), where n is the length of the input array and m is the length of the longest string in the array. The space complexity is O(n * m), since the hash map can potentially store n strings of length m.

### Approach 2: Using a Map and Adding up the ASCII values

To solve this problem, we can create a hash map where the keys are the sum of the ASCII values of each character in each string in the input array, and the values are arrays containing the anagrams. Then, we can iterate through the input array and add each string to the appropriate value array in the hash map. Finally, we can return the values of the hash map as the solution.

Here is an example of how this can be implemented in JavaScript:

```javascript
function groupAnagrams(strs) {
  // Create a new empty object, groups, to store the grouped anagrams.
  const groups = {};

  // Iterate through each string, str, in the input array strs.
  for (const str of strs) {
    // Create a hash value for str by adding up the ASCII values of each character in str.
    let hash = 0;
    for (const ch of str) {
      hash += ch.charCodeAt(0);
    }

    // Check if the hash value for str already exists as a key in groups.
    if (groups[hash]) {
      // If it does, append str to the array of strings stored at that key.
      groups[hash].push(str);
    } else {
      // If it does not, create a new key in groups with the hash value of str and set its value to an array containing str.
      groups[hash] = [str];
    }
  }

  // After the loop completes, return the values of groups in a new array.
  return Object.values(groups);
}
```

#### Complexity Analysis

This optimized solution has a time complexity of O(n * m), where n is the number of strings in the input array and m is the average length of the strings. This is because we iterate through each string in the input array and calculate the hash value for each string, which takes O(m) time. The space complexity is O(n), since we store all the strings in the groups object.
