---
title: Top K Frequent Elements
description: Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Three approaches to solve the problem are discussed, with time and space complexity analysis.
keywords: Top K Frequent Elements, integer array, nums, k, most frequent elements, order, example, input, output, solution, map, frequency, element, iterate, array, sort, pairs, descending order, JavaScript, approach, number, array of number, frequency pairs, first k numbers, OR operator, if statement, has method, time complexity, O(n log(n)), space complexity, sort function, min heap, Heap class, push, pop, size, toArray, frequency map, element, min heap, pair, push, pop, top k elements
---

import DifficultyChip from '../../components/DifficultyChip';

# [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) <DifficultyChip difficulty="medium" />

<div className="iframe-container">
	<iframe className="responsive-iframe" src="https://www.youtube.com/embed/YPTqKIgVk-k"
					title="YouTube video player" frameBorder="0"
					allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
					allowFullScreen></iframe>
</div>

## Problem

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

Example 1:

```text
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

Example 2:

```text
Input: nums = [1], k = 1
Output: [1]
```

## Solution

To find the k most frequent elements in an array, you can use the following steps:

1. Create a map to store the frequency of each element in the array.
2. Iterate through the array and update the frequency of each element in the map.
3. Sort the `pairs` by frequency in descending order.
4. Return the first k elements from the sorted map.

Here is a solution in JavaScript:

### Approach 1: Frequency Sorting

The first step creates a map that stores the frequency of each number in the input array nums. It then converts the map to an array of [number, frequency] pairs, sorts the array in descending order by frequency, and returns the first k numbers.

```javascript
function topKFrequent(nums, k) {
  // Create a map to store the frequency of each number
  const frequencyMap = new Map();
  for (const num of nums) {
    if (frequencyMap.has(num)) {
      frequencyMap.set(num, frequencyMap.get(num) + 1);
    } else {
      frequencyMap.set(num, 1);
    }
  }

  // Create an array of [number, frequency] pairs
  const pairs = Array.from(frequencyMap.entries());

  // Sort the array in descending order by frequency
  pairs.sort((a, b) => b[1] - a[1]);

  // Return the first k numbers
  return pairs.slice(0, k).map((pair) => pair[0]);
}
```

This version below uses a more concise way of updating the frequency of each number in the map by using the OR operator (||). This avoids the need for an if statement and the has method.

```javascript
function topKFrequent(nums, k) {
  // Create a map to store the frequency of each number
  const frequencyMap = new Map();
  for (const num of nums) {
    frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);
  }

  // Create an array of [number, frequency] pairs
  const pairs = Array.from(frequencyMap.entries());

  // Sort the array in descending order by frequency
  pairs.sort((a, b) => b[1] - a[1]);

  // Return the first k numbers
  return pairs.slice(0, k).map((pair) => pair[0]);
}
```

#### Complexity Analysis

The time complexity of the first implementation is O(n * log(n)), where n is the length of the input array nums. This is because the function uses the sort function to sort the array of [number, frequency] pairs, which has a time complexity of O(n * log(n)).

The space complexity of the first implementation is O(n), because it creates a map that stores the frequency of each number in the input array nums, and an array of [number, frequency] pairs. The size of these data structures is proportional to the size of the input array, so the space complexity is O(n).

Note that this analysis assumes that the sort function has a time complexity of O(n * log(n)). Some implementations of the sort function may have a different time complexity, such as O(n^2) or O(n * log(n) * log(n)). However, in practice, the time complexity of the sort function is usually O(n * log(n)), so this is a reasonable assumption.

### Approach 2: Using Heap

The Heap class is a min heap implementation that provides the following methods: push(element), pop(), and size(). The toArray() method returns an array representation of the heap.

```javascript
function topKFrequent(nums, k) {
  // Create a map to store the frequency of each element
  const frequencyMap = new Map();
  for (const num of nums) {
    frequencyMap.set(num, (frequencyMap.get(num) || 0) + 1);
  }

  // Create a priority queue (min heap) to store the top k frequent elements
  const heap = new Heap((a, b) => frequencyMap.get(a) - frequencyMap.get(b));

  // Push all elements into the heap
  for (const num of frequencyMap.keys()) {
    heap.push(num);
    // If the heap size is greater than k, remove the smallest element from the heap
    if (heap.size() > k) heap.pop();
  }

  // Return the top k frequent elements
  return heap.toArray();
}
```

#### Complexity Analysis

The time complexity is O(n log k) because we iterate through the array nums once to create the frequency map, which takes O(n) time, and we also iterate through the keys of the frequency map and push each element into the heap, which takes O(n log k) time. The overall time complexity is O(n) + O(n log k) = O(n log k).

The space complexity is O(n) because we create a map to store the frequency of each element in the array, which takes O(n) space, and we also create a heap to store the top k frequent elements, which also takes O(n) space. The overall space complexity is O(n) + O(n) = O(n).
