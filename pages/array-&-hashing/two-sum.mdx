---
title: Two Sum
description: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. Three approaches to solve the problem are discussed, with time and space complexity analysis.
keywords: Two Sum, target, array, integers, indices, add up
---

import DifficultyChip from '../../components/DifficultyChip'

# [Two Sum](https://www.leetcode.com/problems/two-sum/) <DifficultyChip difficulty="easy" />

<div className="iframe-container">
  <iframe className="responsive-iframe" src="https://www.youtube.com/embed/KLlXCFG5TnA"
          title="YouTube video player" frameBorder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen></iframe>
</div>

## Problem

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```text
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

Example 2:

```text
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

Example 3:

```text
Input: nums = [3,3], target = 6
Output: [0,1]
```

## Solution

### Approach 1: Brute Force

One way to solve this problem is to use a brute force approach, where we compare each element in the array with every other element to check if they add up to the target. This would give us a solution with a time complexity of **O(n^2)**.

Here is some sample code that demonstrates this approach:

```javascript
function twoSum(nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[i] + nums[j] === target) {
        return [i, j];
      }
    }
  }
  return [];
}
```
#### Complexity Analysis

The time complexity of this approach is **O(n^2)**, since we are using two nested loops.

The space complexity is O(1), because it does not use any additional data structures and only stores a few variables in memory (such as `i`, `j`, and `nums`).

### Approach 2: Hash Table

The solution above works well for small arrays, but for larger arrays it may not be efficient enough. We can improve the time complexity by using a more efficient data structure such as a hash map.

Here is a solution that uses a hash map to store the indices of the elements as we iterate through the array:

```javascript
function twoSum(nums, target) {
  const hashTable = {};
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    if (target - num in hashTable) {
      return [hashTable[target - num], i];
    }
    hashTable[num] = i;
  }
  return [];
}
```

#### Complexity Analysis

This solution has a time complexity of **O(n)** and a space complexity of **O(n)**, which is much more efficient than the brute force approach.

The space complexity is O(n), because it uses a hash table (implemented as an object in JavaScript) to store the indices of the elements in the input array. The size of the hash table will grow as the size of the input array grows, so the space complexity is proportional to the size of the input array.

### Approach 3: Hash Map

One potential optimization for the hash map solution is to use a Map object instead of a plain JavaScript object to store the indices of the elements. This can potentially be faster, especially for large arrays, because the Map object has a faster lookup time compared to a plain object.

Here is the optimized version of the code that uses a Map object:

```javascript
function twoSum(nums, target) {
  const hashTable = new Map();
  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    if (hashTable.has(target - num)) {
      return [hashTable.get(target - num), i];
    }
    hashTable.set(num, i);
  }
  return [];
}
```

Another optimization is to use a more advanced data structure such as a balanced binary search tree (e.g. a red-black tree) to store the indices of the elements. This can potentially improve the time complexity and space complexity of the solution, but it may not be necessary for this case.

##### Additional

In JavaScript, objects are implemented as hash tables under the hood, with the keys being hashed to create an index that points to the corresponding value. However, the hash function used for objects can be slower than the one used for Maps, especially for large objects with many keys.

Map objects use a hash function that is optimized for performance, which makes them generally faster than plain objects for inserting, deleting, and looking up keys. Map objects also have a faster iteration time compared to plain objects, because the keys are stored in a specific order.

Overall, Map objects are a more efficient data structure for storing key-value pairs in JavaScript, and they are generally a good choice when you need to store a large number of keys and you need fast insertion, deletion, and lookup times.

#### Complexity Analysis

The time complexity is O(n) because the algorithm only needs to iterate through the input array once to find the indices of the two elements that sum to the target value. This is faster than the first approach, which uses nested loops and therefore has to iterate through the input array twice, resulting in a time complexity of O(n^2).

The space complexity is also O(n), because it uses a JavaScript Map object to store the indices of the elements in the input array. Like the hash table in the second approach, the size of the Map object will grow as the size of the input array grows, so the space complexity is also proportional to the size of the input array.
